# IMPORTS
import numpy as np
import matplotlib.pyplot as plt
import mpl_toolkits.mplot3d.axes3d as p3
import matplotlib.animation as animation
%matplotlib qt

def generate_data(nbr_iterations, nbr_elements):
    """
    Generates dummy data.
    The elements will be assigned random initial positions and speed.
    Args:
        nbr_iterations (int): Number of iterations data needs to be generated for.
        nbr_elements (int): Number of elements (or points) that will move.
    Returns:
        list: list of positions of elements. (Iterations x (# Elements x Dimensions))
    """
    dims = (3,1)

    # Random initial positions.
    gaussian_mean = np.zeros(dims)
    gaussian_std = np.ones(dims)
    start_positions = np.array(list(map(np.random.normal, gaussian_mean, gaussian_std, [nbr_elements] * dims[0]))).T

    # Random speed
    start_speed = np.array(list(map(np.random.normal, gaussian_mean, gaussian_std, [nbr_elements] * dims[0]))).T

    # Computing trajectory
    data = [start_positions]
    for iteration in range(nbr_iterations):
        previous_positions = data[-1]
        new_positions = previous_positions + start_speed
        data.append(new_positions)

    return data

def animate_scatters(iteration, data, scatters, R, C):
    """
    Update the data held by the scatter plot and therefore animates it.
    Args:
        iteration (int): Current iteration of the animation
        data (list): List of the data positions at each iteration.
        scatters (list): List of all the scatters (One per element)
    Returns:
        list: List of scatters (One per element) with new coordinates
    """
    scatters._offsets3d = (np.append(np.array([100.0, 100.0]), data[iteration][:,0]), np.append(np.array([100.0, 100.0]),data[iteration][:,1]), np.append(np.array([100.0, 100.0]), data[iteration][:,2]))
    scatters.set_array(np.append(np.array([1, 10]), C[iteration]))
    scatters.set_sizes(np.append(np.array([1, 1]),R[iteration]))
    #for i in range(data[0].shape[0]):
    #    scatters[i]._offsets3d = (np.array([100.0, data[iteration][i,0]]), np.array([100.0,data[iteration][i,1]]), np.array([100.0, data[iteration][i,2]]))
    #    scatters[i].set_array(np.asarray([10, C[iteration, i]]))
    #    scatters[i].set_sizes([1, R[iteration, i]])
    return scatters

def main(data, R, fates, save=False):
    """
    Creates the 3D figure and animates it with the input data.
    Args:
        data (list): List of the data positions at each iteration.
        save (bool): Whether to save the recording of the animation. (Default to False).
    """

    # Attaching 3D axis to the figure
    fig = plt.figure(figsize=(10,10))
    ax  = p3.Axes3D(fig)
    r0  = (np.amax(R)*12500.0) / np.amin(R[-1,:])/2.0
    R = (R/np.amax(R))*r0
    C = np.empty(R.shape)
    c = 0
    for i in range(len(fates)):
        for j in range(len(fates[i])):
            if fates[i][j] == 0:
                c = 5
            elif fates[i][j] == 1:
                c = 4
            elif fates[i][j] == 2:
                c = 1
                    
            C[i,j] = c
    C = np.asarray(C)
    # Initialize scatters
    #scatters = [ ax.scatter(np.array([100.0, data[0][i,0]]), np.array([100.0,data[0][i,1]]), np.array([100.0, data[0][i,2]]),cmap='tab10', s=[1,r0], c=np.asarray([10, C[0][i]])) for i in range(data[0].shape[0]) ]
    scatters = ax.scatter(np.append(np.array([100.0, 100.0]), data[0][:,0]), np.append(np.array([100.0, 100.0]),data[0][:,1]), np.append(np.array([100.0, 100.0]), data[0][:,2]),cmap='tab10', s=np.append(np.array([1, 1]),R[0]), c=np.append(np.array([1, 10]), C[0]))
    # Number of iterations
    iterations = len(data)
    xmin = min(data[:,0,0])-2
    xmax = max(data[:,0,0])+2
    ymin = min(data[:,0,1])-2
    ymax = max(data[:,0,1])+2
    zmin = min(data[:,0,2])-2
    zmax = max(data[:,0,2])+2
    
    maxx = xmax
    minn = xmin
    if ymax > maxx:
        maxx = ymax
    if ymin < minn:
        minn = ymin
    
    if zmax > maxx:
        maxx = zmax
    if zmin < minn:
        minn = zmin
    #Create 3d axes
    #ax = plt.axes(xlim = (xmin,xmax),ylim=(ymin,ymax),zlim = (zmin,zmax),projection="3d")
    
    # Setting the axes properties
    ax.set_xlim3d([minn, maxx])
    ax.set_xlabel('X')

    ax.set_ylim3d([minn, maxx])
    ax.set_ylabel('Y')

    ax.set_zlim3d([minn, maxx])
    ax.set_zlabel('Z')

    #ax.set_title('')
    ax.grid(False)
    # Provide starting angle for the view.
    ax.view_init(25, 10)
    
    ani = animation.FuncAnimation(fig, animate_scatters, iterations, fargs=(data, scatters, R, C),
                                       interval=50, blit=False, repeat=True)

    if save:
        Writer = animation.writers['ffmpeg']
        writer = Writer(fps=25, metadata=dict(artist='Me'), bitrate=1800, extra_args=['-vcodec', 'libx264'])
        ani.save('Desktop/embryo_anim.mp4', writer=writer)

    #plt.show()
times = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/times.dat", comments="#", delimiter=",", unpack=False)
X = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/X.dat", comments="#", delimiter=",", unpack=False)
Y = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/Y.dat", comments="#", delimiter=",", unpack=False)
Z = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/Z.dat", comments="#", delimiter=",", unpack=False)
R = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/R.dat", comments="#", delimiter=",", unpack=False)
fates = np.loadtxt("/home/pablo/Desktop/PhD/EmbryonicDev/Nestor/code/AgentModel/Results/fates.dat", comments="#", delimiter=",", unpack=False)

data = np.dstack([X,Y,Z])
main(data, R, fates, save=True)

